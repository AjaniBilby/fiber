# This will not execute
# The purpose is to list every possible variable of every command
# Not to actually execute

# Set
set @rA @rB
set @rA local
set @rA parse
set &rA 0x1
set &rA 24u
set &rA -24i
set &rA 0.24f

# Math
#  A = A + B
math &rA + &rB
math &rA + 1i
math &rA + 1u
math &rA + 1.0f
math &rA - &rB
math &rA - 1i
math &rA - 1u
math &rA - 1.0f
math &rA * &rB
math &rA * 1i
math &rA * 1u
math &rA * 1.0f
math &rA / &rB
math &rA / 1i
math &rA / 1u
math &rA / 1.0f
math &rA % &rB
math &rA % 1i
math &rA % 1u
math &rA % 1.0f
#  Addresses can only add and subtract
math @rA + 1i
math @rA + 1u
math @rA - 1i
math @rA - 1u

# Return
rtrn

# Comparing
cmpr @rA = @rB &rC
cmpr @rA = &rB &rC
cmpr &rA = &rB &rC
cmpr &rA = @rB &rC
cmpr @rA > @rB &rC
cmpr @rA > &rB &rC
cmpr &rA > &rB &rC
cmpr &rA > @rB &rC
cmpr @rA < @rB &rC
cmpr @rA < &rB &rC
cmpr &rA < &rB &rC
cmpr &rA < @rB &rC
cmpr &rA < 0.0f &rC
cmpr &rA < 0.0i &rC
cmpr &rA < 0.0u &rC
cmpr &rA > 0.0f &rC
cmpr &rA > 0.0i &rC
cmpr &rA > 0.0u &rC
cmpr &rA = 0.0f &rC
cmpr &rA = 0.0i &rC
cmpr &rA = 0.0u &rC

# Bitwise
bit &rA and &rB
bit &rA and 0x1
bit &rA and -1i
bit &rA and 24u
bit &rA not _
bit &rA not _
bit &rA not _
bit &rA not _
bit &rA or &rB
bit &rA or 0x1
bit &rA or -1i
bit &rA or 24u
bit &rA xor &rB
bit &rA xor 0x1
bit &rA xor -1i
bit &rA xor 24u
bit &rA shift -1i
bit &rA shift 1i

# Gate
if &rA
{

}
else
{

}


# Function definition
func test 2u
{
	rtrn
}
