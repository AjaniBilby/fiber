function main 0x8 0

	# @param index - uint64   (8)
	# @local received uint8   (1)
	# @local result uint64    (8)
	# @returns uint64
	function fib 0x24 8
		# Get local scope address
		mode rA uint64
		local rA


		# recevied = false
		#  Setup address
		clone rA rC
		math rC add 0x8 rC
		#  Generate data
		mode rD uint8
		set rD 0x0
		#  Write data
		push rD rC

		# result = 0
		#  Setup address
		clone rA rC
		math rC add 0x10 rC
		#  Generate data
		mode rD uint64
		set rD 0x0
		#  Write data
		push rD rC



		# if (index <= 1) == if (!(index > 1))
		#  Read index into rB
		mode rB uint64
		pull rB rA
		#  Create comparator
		mode rC uint64
		set rC 0x1
		#  Boolean result
		stringify rB rK rL
			mem unalloc rK rL
		stringify rC rK rL
			mem unalloc rK rL
		mode rD uint8
		compare rB > rC rD
		stringify rD rK rL
			mem unalloc rK rL
		bit rD not 0x0 rD
		stringify rD rK rL
			mem unalloc rK rL

		if rD
			# result = 1
			#  Setup address
			clone rA rC
			math rC add 0x10 rC
			#  Push value
			write rC 0x0000000000000001

			yeild rC
			return
		end


		# @local boolean shouldExit
		# @returns boolean
		function wrapUp 1 1
			# Load parent scope into rA
			mode rA uint64
			instance parent rA
			local rA rA

			# Read received into rB
			#  Setup address
			clone rA rC
			math rC add 0x8 rC
			#  Pull value
			mode rB uint8
			pull rB rC

			if rB
				# shouldExit = true
				local rA
				write rA 0xFF

				# yeild shouldExit
				yeild rA

				# Print resultant value
				#  Get result address
				clone rA rB
				math rB add 0x10 rB
				#  Read result
				mode rC uint64
				pull rC rB
				stringify rC rD rE

				return
			end

			# Set received = true
			write rC 0xFF

			# shouldExit = false
			local rA
			write rA 0x00

			# yeild shouldExit
			yeild rA
			return

		end




		# fib(index - 1)
		instance create fib rB

		# parse index-1
		#  read index into rC
		mode rC uint64
		pull rC rA
		math rC subtract 0x1 rC
		#  get instance's local space
		local rD rB
		# write index-1 to child function
		push rC rB

		instance yeild rB
			local rA

			# Read value into rB
			mode rB uint64
			data rB
			pull rB rB

			# result += value
			#  Setup address
			clone rA rC
			math rC add 0x10 rC
			mode rD uint64
			pull rD rC
			math rD add rB rD
			push rD rC
		end

		instance return rB
			instance create wrapUp rB
			instance yeild rB
				# Get Result space
				mode rA uint64
				data rA

				# Read result
				mode rB uint8
				pull rB rA
				if rB
					return
				end
			end
			instance execute rB
		end

		instance execute rB


		# parse index-2
		#  read index into rC
		mode rC uint64
		pull rC rA
		math rC subtract 0x2 rC
		#  get instance's local space
		local rD rB
		# write index-1 to child function
		push rC rB

		instance yeild rB
			local rA

			# Read value into rB
			mode rB uint64
			data rB
			pull rB rB

			# result += value
			#  Setup address
			clone rA rC
			math rC add 0x10 rC
			mode rD uint64
			pull rD rC
			math rD add rB rD
			push rD rC
		end

		instance return rB
			instance create wrapUp rB
			instance yeild rB
				# Get Result space
				mode rA uint64
				data rA

				# Read result
				mode rB uint8
				pull rB rA
				if rB
					return
				end
			end
			instance execute rB
		end

		instance execute rB


	end





	# Load local memory address
	mode rA uint64
	local rA

	# Create function instance
	instance create fib rB

	# Parse input data
	#  Get the local memory address of the function instance
	local rE rB

	# Set index to 2 !317811
	mode rD uint64
	; set rD 0x4D973
	set rD 0x1
	push rD rE

	# Setup function result callback
	instance yeild rB
		mode rA uint64
		data rA

		# Read the result into rB
		mode rB uint64
		pull rB rA

		# Convert rC into a string
		mode rC uint64
		mode rD uint64
		stringify rB rC rD
		ss out rC rD
		mem unalloc rC rD
	end

	# Stop execution when the function completes
	instance return rB
		return
	end

	# execute instance
	instance execute rB

end


# Run main function
instance create main rA
# Manually parse arguments here
instance execute rA
